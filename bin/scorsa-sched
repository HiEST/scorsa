#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# scorsa-sched -- Simulate the execution of a workload
#
# Given a system configuration and layout, and a workload description,
# simulate the execution of all the jobs in the workload generating a schedule
# that includes when and where the jobs are executed.
#
# Copyright © 2016 Jordà Polo <jorda.polo@bsc.es>

import sys
import logging
import argparse
import configparser
import json
import numpy as np

import scorsa
import policies

logging.basicConfig(format="%(message)s", level=logging.ERROR)

ap = argparse.ArgumentParser()
ap.add_argument("-c", "--config", dest="c", required=True,
                help="System configuration file")
ap.add_argument("-l", "--layout", dest="l", required=True,
                help="System layout file")
ap.add_argument("-w", "--workload", dest="w", required=True,
                help="JSON workload file")
args = ap.parse_args()

config = configparser.ConfigParser(delimiters=("="))
config.read(args.c)

length = config.getfloat("simulator", "length")
step = config.getfloat("simulator", "step")
digits = config.getint("simulator", "digits")
families = json.loads(config.get("system", "families"))

layout = scorsa.map_layout(np.genfromtxt(args.l, delimiter=',', dtype=None))

with open(args.w) as w:
    jobs = json.load(w)

index = {job["id"]: job for job in jobs}
system = {}

arrivals = {} # job IDs indexed by arrival time
completions = {} # job IDs indexed by completion time

schedule = {} # scheduling decisions indexed by job ID

running = [] # current job IDs being executed
pending = [] # current submitted job IDs that haven't been scheduled yet
available = {} # current available resources indexed by family

for f in families:
    system[f] = {}
    system[f]["cores"] = config.getint("system.%s" % f, "cores")
    system[f]["mem"] = config.getint("system.%s" % f, "mem")
    r = json.loads(config.get("system.%s" % f, "range"))
    available[f] = range(r[0], r[1])

for j in jobs:
    s = scorsa.f2step(float(j["arrival"]), step, digits)
    if not s in arrivals:
        arrivals[s] = []
    arrivals[s].append(j["id"])

for s in scorsa.rangef(0.0, length, step, digits):
    if s in completions:
        for jid in completions[s]:
            family = schedule[jid]["family"]
            cpus = schedule[jid]["cpus"]
            available[family] += cpus
            running.remove(jid)

    if s in arrivals:
        pending = pending + arrivals[s]

    while True:
        sched = policies.sched_min_exec(system, available, index, pending)

        if not sched:
            break

        jid, family, num_cpus, num_nodes, time = sched

        pending.remove(jid)
        cpus = available[family][0:num_cpus]
        available[family] = available[family][num_cpus:]

        e = s + scorsa.f2step(time, step, digits)

        schedule[jid] = {}
        schedule[jid]["family"] = family
        schedule[jid]["cpus"] = cpus
        schedule[jid]["nodes"] = num_nodes
        schedule[jid]["start"] = s
        schedule[jid]["end"] = e

        running.append(jid)

        if not e in completions:
            completions[e] = []
        completions[e].append(jid)

print json.dumps(schedule)
