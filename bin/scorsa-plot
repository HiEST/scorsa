#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# scorsa-plot -- Plot a workload schedule
#
# Given a system configuration, a workload description, and a schedule as
# generated by `scorsa-sched', this program generates a plot displaying the
# amount of CPUs used by each job over time, as well as submission times for
# each job in the workload.
#
# Copyright © 2016 Jordà Polo <jorda.polo@bsc.es>

import sys
import logging
import argparse
import configparser
import json
import copy

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import scorsa
import plot

logging.basicConfig(format="%(message)s", level=logging.ERROR)

ap = argparse.ArgumentParser()
ap.add_argument("-c", "--config", dest="c", required=True,
                help="System configuration file")
ap.add_argument("-w", "--workload", dest="w", required=True,
                help="JSON workload file")
ap.add_argument("-s", "--schedule", dest="s", required=True,
                help="JSON schedule file")
ap.add_argument("-t", "--stats", dest="t", required=True,
                help="JSON stats file")
args = ap.parse_args()

config = configparser.ConfigParser(delimiters=("="))
config.read(args.c)

length = config.getfloat("simulator", "length")
step = config.getfloat("simulator", "step")
digits = config.getint("simulator", "digits")
families = json.loads(config.get("system", "families"))

with open(args.w) as w:
    jobs = json.load(w)

with open(args.s) as s:
    schedule = json.load(s)

with open(args.t) as t:
    stats = json.load(t)

index = {job["id"]: job for job in jobs}

for k, v in schedule.iteritems():
    schedule[k]["id"] = k

mpl.rcParams['axes.titlesize'] = 'medium'
mpl.rcParams['axes.labelsize'] = 'small'
mpl.rcParams['xtick.labelsize'] = 'small'
mpl.rcParams['ytick.labelsize'] = 'small'

_, ax = plt.subplots(len(families)+1, sharex=True, sharey=False, squeeze=False)
ax[-1,0].set_xlabel('Time (s)')

for a, f in enumerate(families):
    ax[a,0].set_xlim(0.0, length)

    r = json.loads(config.get("system.%s" % f, "range"))
    ax[a,0].set_ylabel('Number of CPUs\n(%s)' % (f))
    ax[a,0].set_ylim(0, len(range(r[0], r[1])))

    subs = [s for s in schedule.values() if s["family"] == f]
    order = []
    for i in sorted(subs, key=lambda k: k["end"], reverse=True):
        order.append(i["id"])

    x = np.array([i for i in scorsa.rangef(0.0, length, step, digits)])

    running = {}
    for jid in order:
        start = schedule[jid]["start"]
        end = schedule[jid]["end"]
        running[jid] = np.zeros(len(x), dtype=np.int)
        for i in scorsa.rangef(start, min(end, length), step, digits):
            running[jid][int(i / step)] = len(schedule[jid]["cpus"])

    # accumulate running CPUs to plot stepped figure
    arunning = copy.deepcopy(running)

    for m, i in enumerate(order):
        for n, j in enumerate(order):
            if n >= m:
                break
            start = schedule[i]["start"]
            end = schedule[i]["end"]
            for k in scorsa.rangef(start, min(end, length), step, digits):
                k = int(k / step)
                arunning[i][k] = arunning[i][k] + running[j][k]

    # display submissions
    for jid in order:
        arrival = index[jid]['arrival']
        ax[a,0].axvline(arrival - arrival % step, linewidth=0.1,
                        color='#666666', linestyle='dotted')

    for jid in reversed(order):
        y = np.array(arunning[jid])
        ax[a,0].step(x, y, '-', linewidth=0.01, color='black', where='post')
        plot.fill_steps(ax[a,0], x, y, 0, step_where="post",
                        facecolor=index[jid]['color'], linewidth=0.0)

a += 1
x = [s["time"] for s in stats]
f = [s["frag"] for s in stats]
d = [s["dist"] for s in stats]
ax[a,0].set_ylabel('Fragmentation & Distance')
ax[a,0].set_ylim(0.0, 1.0)
ax[a,0].step(x, f, '-', where='post', label='Fragmentation')
ax[a,0].step(x, d, '-', where='post', label='Distance')
ax[a,0].legend(prop={'size': 8})

plt.tight_layout()
plt.savefig('plot.pdf', bbox_inches='tight')
