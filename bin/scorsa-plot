#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# scorsa-plot -- Plot a workload schedule
#
# Given a system configuration, a workload description, and a schedule as
# generated by `scorsa-sched', this program generates a plot displaying the
# amount of CPUs used by each job over time, as well as submission times for
# each job in the workload.
#
# Copyright © 2016 Jordà Polo <jorda.polo@bsc.es>

import sys
import logging
import argparse
import configparser
import json
import copy

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import scorsa
import plot

logging.basicConfig(format="%(message)s", level=logging.ERROR)

ap = argparse.ArgumentParser()
ap.add_argument("-c", "--config", dest="c", required=True,
                help="System configuration file")
ap.add_argument("-w", "--workload", dest="w", required=True,
                help="JSON workload file")
ap.add_argument("-s", "--schedule", dest="s", required=True,
                help="JSON schedule file")
args = ap.parse_args()

config = configparser.ConfigParser(delimiters=("="))
config.read(args.c)

length = config.getfloat("simulator", "length")
step = config.getfloat("simulator", "step")
digits = config.getint("simulator", "digits")
families = json.loads(config.get("system", "families"))

with open(args.w) as w:
    jobs = json.load(w)

with open(args.s) as s:
    schedule = json.load(s)

index = {job["id"]: job for job in jobs}

for k, v in schedule.iteritems():
    schedule[k]["id"] = k

mpl.rcParams['axes.titlesize'] = 'medium'
mpl.rcParams['axes.labelsize'] = 'small'
mpl.rcParams['xtick.labelsize'] = 'small'
mpl.rcParams['ytick.labelsize'] = 'small'

fig, ax = plt.subplots(len(families), sharex=True, sharey=False)
ax[-1].set_xlabel('Time (s)')

for a, f in enumerate(families):
    ax[a].set_ylabel('Number of CPUs\n(%s)' % (f))
    ax[a].set_xlim(0.0, length)
    ax[a].set_ylim(0, config.getint("system.%s" % f, "count"))

    subs = [s for s in schedule.values() if s["family"] == f]
    order = []
    for i in sorted(subs, key=lambda k: k["end"], reverse=True):
        order.append(i["id"])

    x = np.array([i for i in scorsa.rangef(0.0, length, step, digits)])

    running = {}
    for jid in order:
        start = schedule[jid]["start"]
        end = schedule[jid]["end"]
        running[jid] = np.zeros(len(x), dtype=np.int)
        for i in scorsa.rangef(start, end, step, digits):
            running[jid][int(i / 60.0)] = schedule[jid]["cpus"]

    # accumulate running CPUs to plot stepped figure
    arunning = copy.deepcopy(running)
    for i in running:
        for j in running:
            if j >= i:
                break
            for k in range(len(running[order[0]])):
                arunning[i][k] = arunning[i][k] + running[j][k]

    # display submissions
    for jid in order:
        arrival = index[jid]['arrival']
        ax[a].axvline(arrival - arrival % step, linewidth=0.1, color='#666666',
                      linestyle='dotted')

    for jid in order:
        y = np.array(arunning[jid])
        ax[a].step(x, y, '-', linewidth=0.01, color='black')
        plot.fill_steps(ax[a], x, y, 0, step_where="pre",
                        facecolor=index[jid]['color'], linewidth=0.0)

plt.tight_layout()
plt.savefig('plot.pdf', bbox_inches='tight')
