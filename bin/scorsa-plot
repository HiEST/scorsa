#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# scorsa-plot -- Plot a workload schedule
#
# Given a system configuration, a workload description, and a schedule as
# generated by `scorsa-sched', this program generates a plot displaying the
# amount of sockets used by each job over time, as well as submission times
# for each job in the workload.
#
# Copyright © 2016 Jordà Polo <jorda.polo@bsc.es>

import sys
import logging
import argparse
import configparser
import json
import copy
import math

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import scorsa
import plot

logging.basicConfig(format="%(message)s", level=logging.ERROR)

ap = argparse.ArgumentParser()
ap.add_argument("-c", "--config", dest="c", required=True,
                help="System configuration file")
ap.add_argument("-w", "--workload", dest="w", required=True,
                help="JSON workload file")
ap.add_argument("-s", "--schedule", dest="s", required=True,
                help="JSON schedule file")
ap.add_argument("-t", "--stats", dest="t", required=True,
                help="JSON stats file")
args = ap.parse_args()

config = configparser.ConfigParser(delimiters=("="))
config.read(args.c)

length = config.getfloat("simulator", "length")
period = config.getfloat("simulator", "period")
digits = config.getint("simulator", "digits")
window_min = config.getfloat("plot", "window_min")
window_max = config.getfloat("plot", "window_max")
submissions = config.getboolean("plot", "submissions")
families = json.loads(config.get("system", "families"))

offset = int(math.floor(window_min / period))

with open(args.w) as w:
    workload = json.load(w)

with open(args.s) as s:
    schedule = json.load(s)

with open(args.t) as t:
    stats = json.load(t)

jobs = {job["id"]: job for job in workload}

for k, v in schedule.iteritems():
    schedule[k]["id"] = k

mpl.rcParams['axes.titlesize'] = 'medium'
mpl.rcParams['axes.labelsize'] = 'small'
mpl.rcParams['xtick.labelsize'] = 'small'
mpl.rcParams['ytick.labelsize'] = 'small'

_, ax = plt.subplots(len(families)+1, sharex=True, sharey=False, squeeze=False)
ax[-1,0].set_xlabel('Time (s)')

for a, f in enumerate(families):
    ax[a,0].set_xlim(0.0, window_max - window_min)

    r = json.loads(config.get("system.%s" % f, "range"))
    ax[a,0].set_ylabel('Number of sockets\n(%s)' % (f))
    ax[a,0].set_ylim(0, len(range(r[0], r[1])))

    subs = [s for s in schedule.values() if s["family"] == f]
    order = []
    for i in sorted(subs, key=lambda k: k["end"], reverse=True):
        if i["start"] <= window_max and i["end"] >= window_min:
            order.append(i["id"])

    steps = scorsa.steps(0.0, window_max - window_min, period, digits)
    x = np.array([i for i in steps])

    running = {}
    for jid in order:
        start = max(schedule[jid]["start"], window_min)
        end = min(schedule[jid]["end"], window_max)
        sockets = scorsa.list_sockets(schedule[jid]["nodes"])
        running[jid] = np.zeros(len(x), dtype=np.int)
        for k in scorsa.steps(start, end, period, digits):
            p = int(k / period) - offset
            running[jid][p] = len(sockets)

    # accumulate running sockets to plot stepped figure
    arunning = copy.deepcopy(running)

    for m, i in enumerate(order):
        start = max(schedule[i]["start"], window_min)
        end = min(schedule[i]["end"], window_max)
        for n, j in enumerate(order):
            if n >= m:
                break
            for k in scorsa.steps(start, end, period, digits):
                p = int(k / period) - offset
                arunning[i][p] = arunning[i][p] + running[j][p]

    # display submissions
    if submissions:
        for jid in order:
            arrival = jobs[jid]['arrival']
            ax[a,0].axvline(arrival - arrival % period, linewidth=0.1,
                            color='#666666', linestyle='dotted')

    for jid in reversed(order):
        y = np.array(arunning[jid])
        ax[a,0].step(x, y, '-', linewidth=0.01, color='black', where='post')
        plot.fill_steps(ax[a,0], x, y, 0, step_where="post",
                        facecolor=jobs[jid]['color'], linewidth=0.0)

a += 1
x = [s["time"] for s in stats][:-offset or None]
f = [s["frag"] for s in stats][offset:]
fa = [s["frag_lookahead"] for s in stats][offset:]
fw = [s["frag_workload"] for s in stats][offset:]
d = [s["dist"] for s in stats][offset:]
r = [s["reuse"] for s in stats][offset:]
b = [s["backscale"] for s in stats][offset:]
ax[a,0].set_ylabel('Metrics')
ax[a,0].set_ylim(0.0, 1.0)
ax[a,0].step(x, f, '-', where='post', label='System fragmentation')
ax[a,0].step(x, fa, '-', where='post', label='Sys. frag. lookahead')
ax[a,0].step(x, fw, '-', where='post', label='Workload fragmentation')
ax[a,0].step(x, d, '-', where='post', label='Distance')
ax[a,0].step(x, r, '-', where='post', label='Reuse')
ax[a,0].step(x, b, '-', where='post', label='Backscale')
ax[a,0].legend(prop={'size': 8})

plt.tight_layout()
plt.savefig('plot.pdf', bbox_inches='tight')
