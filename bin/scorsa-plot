#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# scorsa-plot -- Plot a workload schedule
#
# Given a system configuration, a workload description, and a schedule as
# generated by `scorsa-sched', this program generates a plot displaying the
# amount of CPUs used by each job over time, as well as submission times for
# each job in the workload.
#
# Copyright © 2016 Jordà Polo <jorda.polo@bsc.es>

import sys
import logging
import argparse
import configparser
import json
import copy
import math

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import scorsa
import plot

logging.basicConfig(format="%(message)s", level=logging.ERROR)

ap = argparse.ArgumentParser()
ap.add_argument("-c", "--config", dest="c", required=True,
                help="System configuration file")
ap.add_argument("-w", "--workload", dest="w", required=True,
                help="JSON workload file")
ap.add_argument("-s", "--schedule", dest="s", required=True,
                help="JSON schedule file")
ap.add_argument("-t", "--stats", dest="t", required=True,
                help="JSON stats file")
args = ap.parse_args()

config = configparser.ConfigParser(delimiters=("="))
config.read(args.c)

length = config.getfloat("simulator", "length")
step = config.getfloat("simulator", "step")
digits = config.getint("simulator", "digits")
window_min = config.getfloat("plot", "window_min")
window_max = config.getfloat("plot", "window_max")
families = json.loads(config.get("system", "families"))

offset = int(math.floor(window_min / step))

with open(args.w) as w:
    jobs = json.load(w)

with open(args.s) as s:
    schedule = json.load(s)

with open(args.t) as t:
    stats = json.load(t)

index = {job["id"]: job for job in jobs}

for k, v in schedule.iteritems():
    schedule[k]["id"] = k

mpl.rcParams['axes.titlesize'] = 'medium'
mpl.rcParams['axes.labelsize'] = 'small'
mpl.rcParams['xtick.labelsize'] = 'small'
mpl.rcParams['ytick.labelsize'] = 'small'

_, ax = plt.subplots(len(families)+1, sharex=True, sharey=False, squeeze=False)
ax[-1,0].set_xlabel('Time (s)')

for a, f in enumerate(families):
    ax[a,0].set_xlim(0.0, window_max - window_min)

    r = json.loads(config.get("system.%s" % f, "range"))
    ax[a,0].set_ylabel('Number of CPUs\n(%s)' % (f))
    ax[a,0].set_ylim(0, len(range(r[0], r[1])))

    subs = [s for s in schedule.values() if s["family"] == f]
    order = []
    for i in sorted(subs, key=lambda k: k["end"], reverse=True):
        if i["start"] <= window_max and i["end"] >= window_min:
            order.append(i["id"])

    x_steps = scorsa.rangef(0.0, window_max - window_min, step, digits)
    x = np.array([i for i in x_steps])

    running = {}
    for jid in order:
        start = max(schedule[jid]["start"], window_min)
        end = min(schedule[jid]["end"], window_max)
        cpus = scorsa.list_cpus(schedule[jid]["nodes"])
        running[jid] = np.zeros(len(x), dtype=np.int)
        for k in scorsa.rangef(start, end, step, digits):
            p = int(k / step) - offset
            running[jid][p] = len(cpus)

    # accumulate running CPUs to plot stepped figure
    arunning = copy.deepcopy(running)

    for m, i in enumerate(order):
        start = max(schedule[i]["start"], window_min)
        end = min(schedule[i]["end"], window_max)
        for n, j in enumerate(order):
            if n >= m:
                break
            for k in scorsa.rangef(start, end, step, digits):
                p = int(k / step) - offset
                arunning[i][p] = arunning[i][p] + running[j][p]

    # display submissions
    for jid in order:
        arrival = index[jid]['arrival']
        ax[a,0].axvline(arrival - arrival % step, linewidth=0.1,
                        color='#666666', linestyle='dotted')

    for jid in reversed(order):
        y = np.array(arunning[jid])
        ax[a,0].step(x, y, '-', linewidth=0.01, color='black', where='post')
        plot.fill_steps(ax[a,0], x, y, 0, step_where="post",
                        facecolor=index[jid]['color'], linewidth=0.0)

a += 1
x = [s["time"] for s in stats]
f = [s["frag"] for s in stats]
d = [s["dist"] for s in stats]
r = [s["reuse"] for s in stats]
b = [s["backscale"] for s in stats]
ax[a,0].set_ylabel('Metrics')
ax[a,0].set_ylim(0.0, 1.0)
ax[a,0].step(x, f, '-', where='post', label='Fragmentation')
ax[a,0].step(x, d, '-', where='post', label='Distance')
ax[a,0].step(x, r, '-', where='post', label='Reuse')
ax[a,0].step(x, b, '-', where='post', label='Backscale')
ax[a,0].legend(prop={'size': 8})

plt.tight_layout()
plt.savefig('plot.pdf', bbox_inches='tight')
